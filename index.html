<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Pandora的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Pandora的技术博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Pandora的技术博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Pandora的技术博客">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Pandora的技术博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Pandora的技术博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-聊一聊iOS后台任务" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/13/聊一聊iOS后台任务/" class="article-date">
  <time datetime="2016-01-13T12:43:00.000Z" itemprop="datePublished">2016-01-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/13/聊一聊iOS后台任务/">聊一聊iOS后台任务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>iOS开发的过程中常常会有按下home键盘，进入后台，但不希望当前任务立即停止的情况，比如保存数据，断开链接，继续下载文件等，接下来就简单聊下iOS的后台任务。</p>
<h4 id="一，后台任务的分类">一，后台任务的分类</h4><p><strong>程序的5个状态和对应的AppDelegate的7个方法</strong> ：</p>
<ul>
<li>Not Running, 未运行</li>
<li>Inactive,  非活动</li>
<li>Active, 活动</li>
<li>Background, 后台</li>
<li>Suspend, 挂起</li>
</ul>
<p>对应的方法分别是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程启动但还没完成初始化，这个方法是iOS6之后才有的</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application willFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程启动基本完成      </span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用程序将要入非活动状态执行，在此期间，应用程序不接收消息或事件</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationWillResignActive:(<span class="built_in">UIApplication</span> *)application   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用程序入活动状态，这个刚好跟上面那个方法相反</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidBecomeActive:(<span class="built_in">UIApplication</span> *)application    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序被推送到后台，如果要设置后台继续运行，则在这个函数里面设置即可</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application     </span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序从后台将要回到前台</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationWillEnterForeground:(<span class="built_in">UIApplication</span> *)application   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序将要退出</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationWillTerminate:(<span class="built_in">UIApplication</span> *)application</span><br></pre></td></tr></table></figure>
<p>在介绍iOS应用状态5种最基本的状态时，我们发现前台运行有两种状态，分别是Inactive和Active状态。大多数情况下，Inactive状态只是其它状态之间切换时短暂的停留状态，如前后台应用切换时，Inactive状态会在Active和Background之间短暂出现，比如App Switcher/回到原应用的操作等。</p>
<p>用户在按下home键后，app可做的事情有很多，比如听歌、打电话、下载电影、更新数据、定时任务等，可以大致分为两类，注册任务（耗时长）和非注册任务（耗时较短）。</p>
<h4 id="二，非注册任务的运行">二，非注册任务的运行</h4><p>非注册任务一般耗时较短，多用来保存数据或延迟执行某一命令等，通过系统API即可实现。可以先看一段官方实例代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">&#123;</span><br><span class="line">    bgTask = [application beginBackgroundTaskWithName:<span class="string">@"MyTask"</span> expirationHandler:^&#123;</span><br><span class="line">        <span class="comment">// Clean up any unfinished task business by marking where you</span></span><br><span class="line">        <span class="comment">// stopped or ending the task outright.</span></span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the long-running task and return immediately.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>beginBackgroundTaskWithName:expirationHandler:</code>方法标识了一个后台任务的开始，并用过超时处理的回调来结束此任务。那么，超时时间具体是多少？可以通过UIApplication的只读属性backgroundTimeRemaining来获取当前后台任务执行的剩余时间，它不是具体的数字（我执行的时间大概160秒），而是iOS根据当前系统环境综合考量后估算出来的。然后执行expirationHandler回调完成一个后台任务的执行周期。</p>
<h4 id="三，注册任务的流程">三，注册任务的流程</h4><p>有些耗时较长的工作，则需要申请专门的权限来保证正常执行而不被挂起，只有少数几种类型被允许这个做。</p>
<ul>
<li>Apps that play audible content to the user while in the background, such as a music player app</li>
<li>Apps that record audio content while in the background</li>
<li>Apps that keep users informed of their location at all times, such as a navigation app</li>
<li>Apps that support Voice over Internet Protocol (VoIP)</li>
<li>Apps that need to download and process new content regularly</li>
<li>Apps that receive regular updates from external accessories</li>
</ul>
<p>申请使用以上场景的后台权限需要在Xcode-&gt;Capabilities-&gt;Background Mode中配置，如下图所示：</p>
<p><img src="http://7xkptx.com1.z0.glb.clouddn.com/234f23g43g343.png" alt=""></p>
<p>勾选所需的模式后，会自动在app的info.plist文件中添加Required background modes一项，包含了所勾选的后台运行模式。如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;UIBackgroundModes&lt;/key&gt;</span><br><span class="line">    &lt;array&gt;</span><br><span class="line">		&lt;string&gt;fetch&lt;/string&gt;</span><br><span class="line">		&lt;string&gt;voip&lt;/string&gt;</span><br><span class="line">	&lt;/array&gt;</span><br></pre></td></tr></table></figure>
<p>以Background Fetch为例，具体说下任务流程。</p>
<p>首先需要在Xcode Capabilities 中开启Background fetch选项，在<code>didFinishLaunchingWithOptions</code>中设置下获取的时间间隔：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">UIApplication</span> sharedApplication] setMinimumBackgroundFetchInterval:<span class="built_in">UIApplicationBackgroundFetchIntervalMinimum</span>];</span><br></pre></td></tr></table></figure>
<p>如果不对最小后台获取间隔进行设定的话，系统将使用默值<code>UIApplicationBackgroundFetchIntervalNever</code>，也就是永远不进行后台获取。而最小的时间间隔则有系统根据电量、网络状态、用户使用习惯等综合考量后来设定一定的差值，执行fetch任务，具体代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//File: YourAppDelegate.m</span></span><br><span class="line">-(<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application performFetchWithCompletionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">UIBackgroundFetchResult</span>))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UINavigationController</span> *navigationController = (<span class="built_in">UINavigationController</span>*)<span class="keyword">self</span><span class="variable">.window</span><span class="variable">.rootViewController</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> fetchViewController = navigationController<span class="variable">.topViewController</span>;</span><br><span class="line">    <span class="keyword">if</span> ([fetchViewController respondsToSelector:<span class="keyword">@selector</span>(fetchDataResult:)]) &#123;</span><br><span class="line">        [fetchViewController fetchDataResult:^(<span class="built_in">NSError</span> *error, <span class="built_in">NSArray</span> *results)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">                <span class="keyword">if</span> (results<span class="variable">.count</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//Update UI with results.</span></span><br><span class="line">                    <span class="comment">//Tell system all done.</span></span><br><span class="line">                    completionHandler(<span class="built_in">UIBackgroundFetchResultNewData</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    completionHandler(<span class="built_in">UIBackgroundFetchResultNoData</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                completionHandler(<span class="built_in">UIBackgroundFetchResultFailed</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        completionHandler(<span class="built_in">UIBackgroundFetchResultFailed</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与fetch类型的是，后台任务同样可以满足远程通知唤醒app执行某一进程，结束后以本地通知的方式提醒用户，以静默、智能的方式带给用户使用上的绝佳体验，相似的场景还有后台电影、音乐的下载等，在此不多做介绍。</p>
<h4 id="四，后台任务的注意事项">四，后台任务的注意事项</h4><h5 id="1，关于OpenGL_ES">1，关于OpenGL ES</h5><p>有些基于位置的app需要后台定时更新用户的当前位置，导致未知崩溃。原因就是Location update类型的后台任务在更新位置时，需要重新绘制MKMapView，调用了OpenGL ES，而OpenGL ES必须在程序Inactive以前关闭，不然会crash。如<a href="https://developer.apple.com/library/ios/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/ImplementingaMultitasking-awareOpenGLESApplication/ImplementingaMultitasking-awareOpenGLESApplication.html" target="_blank" rel="external">官方文档</a>描述：To summarize, your app needs to call the <code>glFinish</code> function to ensure that all previously submitted commands are drained from the command buffer and are executed by OpenGL ES. After it moves into the background, you must avoid all use of OpenGL ES until it moves back into the foreground.</p>
<p>可以在更新位置之前做一下app状态的检测：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( (appState != <span class="built_in">UIApplicationStateBackground</span>) &amp;&amp; (appState != <span class="built_in">UIApplicationStateInactive</span>)) &#123;</span><br><span class="line">     <span class="comment">// update location</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2，关于CAAnimation动画">2，关于CAAnimation动画</h5><p><img src="http://7xkptx.com1.z0.glb.clouddn.com/ca_architecture_2x.png" alt=""></p>
<p>当app进入background模式时，所有基于Core Animation 的动画将自动停止，这是因为动画的渲染需要调用Open GL或者Core Graphics来实现UIKit层的变动，然后在applicationWillEnterForeground的时候重新启动即可。</p>
<p>参考：</p>
<p><a href="http://onevcat.com/2013/08/ios7-background-multitask/" target="_blank" rel="external">http://onevcat.com/2013/08/ios7-background-multitask/</a></p>
<p><a href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/13/聊一聊iOS后台任务/" data-id="cijdtvvud0001nyb1gxlh2d7m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/background/">background</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post- iOS面试总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/24/ iOS面试总结/" class="article-date">
  <time datetime="2015-12-24T10:14:00.000Z" itemprop="datePublished">2015-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/24/ iOS面试总结/">iOS面试总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>写在前面：iOS开发者水平良莠不齐，个人比较看中知识的全面性、编码规范性及学习能力，最近在面试iOS开发有些心得想和大家分享，整理如下：</p>
<h3 id="一，基础篇">一，基础篇</h3><h4 id="1，关键字">1，关键字</h4><p><code>strong</code> 该属性值对应 <em>_strong 关键字，即该属性所声明的变量将成为对象的持有者；</em></p>
<p><code>weak</code> 该属性对应 <strong>weak 关键字，与 </strong>weak 定义的变量一致，该属性所声明的变量将没有对象的所有权，并且当对象被破弃之后，对象将被自动赋值nil，delegate 和 Outlet 应该用 weak 属性来声明；</p>
<p><code>copy</code> 与 strong 的区别是声明变量是拷贝对象的持有者；</p>
<p><code>assign</code> 一般Scalar Varible用该属性声明，比如,int, BOOL；</p>
<p><code>static</code> 类全局变量，只是在编译时候进行初始化，对于static变量，无论是定义在方法体里面 还是在方法体外面其作用域都一样；</p>
<p><code>extern</code> extern的原理很简单，就是告诉编译器：“你现在编译的文件中，有一个变量虽然没有在本文件中定义，但是它是在别的文件中定义的全局变量，你要放行！”，比如 <code>extern NSString *aaa</code>;</p>
<p><code>const</code> </p>
<ul>
<li>const把对象转换为一个常量，不可修改，比如<code>const int bufSize = 512</code>；</li>
<li>const 对象默认为当前文件的局部变量，在全局作用域声明的const变量是定义该对象的文件的局部变量，不能被其它文件访问，可以加extern解决；</li>
</ul>
<p><code>synchronised</code> 通过对一段代码的使用进行加锁。其他试图执行该段代码的线程都会被阻塞，直到加锁线程退出执行该段被保护的代码段，也就是说<code>@synchronized()</code>代码块中的最后一条语句已经被执行完毕的时候；</p>
<h4 id="2，应用程序的状态">2，应用程序的状态</h4><p><img src="http://7xkptx.com1.z0.glb.clouddn.com/1348823833_6296.png" alt=""></p>
<p>主要考察对app当前状态及生命周期的了解程度。具体如下：</p>
<ul>
<li><code>application:willFinishLaunchingWithOptions:</code> - 这个方法是你在启动时的第一次机会来执行代码</li>
<li><code>application:didFinishLaunchingWithOptions:</code> - 这个方法允许你在显示app给用户之前执行最后的初始化操作</li>
<li><code>applicationDidBecomeActive:</code> - app已经切换到active状态后需要执行的操作</li>
<li><code>applicationWillResignActive:</code> - app将要从前台切换到后台时需要执行的操作</li>
<li><code>applicationDidEnterBackground:</code> - app已经进入后台后需要执行的操作</li>
<li><code>applicationWillEnterForeground:</code> - app将要从后台切换到前台需要执行的操作，但app还不是active状态</li>
<li><code>applicationWillTerminate:</code> - app将要结束时需要执行的操作</li>
</ul>
<h4 id="3，viewController的生命周期">3，<strong>viewController的生命周期</strong></h4><p><strong>单个</strong>：</p>
<ul>
<li>initWithCoder:(NSCoder *)aDecoder：（如果使用storyboard或者xib）    </li>
<li>loadView：加载view    </li>
<li>viewDidLoad：view加载完毕    </li>
<li>viewWillAppear：控制器的view将要显示    </li>
<li>viewWillLayoutSubviews：控制器的view将要布局子控件    </li>
<li>viewDidLayoutSubviews：控制器的view布局子控件完成<br>这期间系统可能会多次调用viewWillLayoutSubviews、viewDidLayoutSubviews 俩个方法  </li>
<li>viewDidAppear:控制器的view完全显示    </li>
<li>viewWillDisappear：控制器的view即将消失的时候<br>这期间系统也会调用viewWillLayoutSubviews 、viewDidLayoutSubviews 两个方法    </li>
<li>viewDidDisappear：控制器的view完全消失的时候</li>
</ul>
<p><strong>多个跳转</strong>：</p>
<ul>
<li>当我们点击push的时候首先会加载下一个界面然后才会调用界面的消失方法</li>
<li>initWithCoder:(NSCoder *)aDecoder：<code>ViewController2</code> (如果用xib创建的情况下）</li>
<li>loadView：<code>ViewController2</code></li>
<li>viewDidLoad：<code>ViewController2</code></li>
<li>viewWillDisappear：<strong>ViewController1</strong> 将要消失</li>
<li>viewWillAppear：<code>ViewController2</code> 将要出现</li>
<li>viewWillLayoutSubviews <code>ViewController2</code></li>
<li>viewDidLayoutSubviews <code>ViewController2</code></li>
<li>viewWillLayoutSubviews:<strong>ViewController1</strong></li>
<li>viewDidLayoutSubviews:<strong>ViewController1</strong></li>
<li>viewDidDisappear:<strong>ViewController1</strong> 完全消失</li>
<li>viewDidAppear:<code>ViewController2</code> 完全出现</li>
</ul>
<h4 id="4，OC设计模式">4，OC设计模式</h4><p>MVC、 delegate、 通知、 KVO、 KVC、 单例、 工厂模式等。</p>
<p>需要分别描述下各自的使用场景，比如通知适合一对多？iOS 代理为啥要用weak修饰? iOS系统单例有哪些？</p>
<h4 id="5，block和weak修饰符的区别">5，<strong>block和</strong>weak修饰符的区别</h4><ul>
<li>__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型；</li>
<li>__weak只能在ARC模式下使用，也只能修饰对象，不能修饰基本数据类型；</li>
<li><strong>block对象可以在block中被重新赋值，</strong>weak不可以；</li>
</ul>
<h4 id="6，Objective-C中类别和类扩展的区别">6，Objective-C中类别和类扩展的区别</h4><p>Class extension常常被误解为一个匿名的category。它们的语法的确很相似。虽然都可以用来为一个现有的类添加方法和属性，但它们的目的和行为却是不同的，category和extensions的不同在于后者可以添加属性；另外类扩展添加的方法是必须要实现的；可以运行时给category通过<code>objc_setAssociatedObject</code>、<code>objc_getAssociatedObject</code>添加和读取属性。</p>
<h4 id="7，copy的使用">7，copy的使用</h4><p>用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</p>
<ul>
<li>因为父类指针可以指向子类对象,使用copy的目的是为了让本对象的属性不受外界影响,使用copy无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.</li>
<li>如果我们使用是strong,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.</li>
</ul>
<h4 id="8，LLVM_与_Clang">8，LLVM 与 Clang</h4><p>Clang 是一个 C++ 编写、基于 LLVM、发布于 LLVM BSD 许可证下的。C/C++/Objective C/Objective C++ 编译器，其目标（之一）就是超越 GCC。</p>
<p>Apple 使用 LLVM 在不支持全部 OpenGL 特性的 GPU (Intel 低端显卡) 上生成代码 (JIT)，令程序仍然能够正常运行。之后 LLVM 与 GCC 的集成过程引发了一些不快，GCC 系统庞大而笨重，而 Apple 大量使用的 Objective-C 在 GCC 中优先级很低。此外 GCC 作为一个纯粹的编译系统，与 IDE 配合很差。加之许可证方面的要求，Apple 无法使用修改版的 GCC 而闭源。于是 Apple 决定从零开始写 C family 的前端，也就是基于 LLVM 的 Clang 了。</p>
<p>Clang 的特性：</p>
<ul>
<li>快，通过编译 OS X 上几乎包含了所有 C 头文件的 carbon.h 的测试，包括预处理 (Preprocess)，语法 (lex)，解析 (parse)，语义分析 (Semantic Analysis)，抽象语法树生成 (Abstract Syntax Tree) 的时间，Clang 是 Apple GCC 4.0 的 2.5x 快。(2007-7-25)   </li>
<li>内存占用小：Clang 内存占用是源码的 130%，Apple GCC 则超过 10x。      </li>
<li>GCC 兼容性。   </li>
<li>设计清晰简单，容易理解，易于扩展增强。与代码基础古老的 GCC 相比，学习曲线平缓。   </li>
<li>基于库的模块化设计，易于 IDE 集成及其他用途的重用。</li>
</ul>
<h4 id="9，BAD_ACCESS如何调试">9，BAD_ACCESS如何调试</h4><p>BAD_ACCESS的出现是因为访问了野指针，比如对一个已经释放的对象执行了release、访问已经释放对象的成员变量或者发消息。</p>
<ul>
<li>重写object的respondsToSelector方法，现实出现EXEC_BAD_ACCESS前访问的最后一个object;</li>
<li>设置 Scheme Zombie 模式；</li>
<li>设置全局断点快速定位问题代码所在行；</li>
<li>Xcode 7 已经集成了BAD_ACCESS捕获功能：<strong>Address Sanitizer</strong>。 用法如下：在配置中勾选✅Enable Address Sanitizer；</li>
</ul>
<h3 id="二，实战篇">二，实战篇</h3><h4 id="10，以下代码运行结果如何?">10，以下代码运行结果如何?</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：死锁</p>
<p>原因：</p>
<ul>
<li>dispatch_sync在等待block语句执行完成，而block语句需要在主线程里执行，所以dispatch_sync如果在主线程调用就会造成死锁；</li>
<li>dispatch_sync是同步的，本身就会阻塞当前线程，也即主线程。而又往主线程里塞进去一个block，所以就会发生死锁；</li>
<li>MainThread等待dispatch_sync，dispatch_sync等待block，block等待 mainquen, mainquen等待MainThread，而MainThread等待dispatch_sync。这样就形成了一个死循环；</li>
</ul>
<h4 id="11，HitTest方法">11，HitTest方法</h4><p><img src="http://7xkptx.com1.z0.glb.clouddn.com/d43g45h47j.png" alt=""></p>
<p>场景：</p>
<p>View A位于上方，View B位于下方。View A上有Button 2 ，View B上有Button 1，如何穿透View A ，点击让Button 2响应？</p>
<p><code>-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</code></p>
<ul>
<li>我们都知道，一个屏幕事件由响应链一步步传下去。这个函数返回的view就是可以让你决定在这个point的事件，你用来接收事件的view。当然，如果这个point不在你的view的范围，返回nil；</li>
<li>如果hitTest返回的view不为空，则会把hitTest返回的view作为第一响应者</li>
<li>如果hitTest返回的view为空，调用次序是从subview top到bottom，包括view本身，知道找到响应者为止。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">View A:</span><br><span class="line">-(<span class="keyword">id</span>)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIView</span> *hitView = [<span class="keyword">super</span> hitTest:point withEvent:event];</span><br><span class="line">    <span class="keyword">if</span> (hitView == <span class="keyword">self</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> hitView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">View B:</span><br><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当touch point是在self.buttonFirst上，则hitTest返回self.buttonFirst</span></span><br><span class="line">    <span class="built_in">CGPoint</span> btnPointInA = [<span class="keyword">self</span><span class="variable">.buttonFirst</span> convertPoint:point fromView:<span class="keyword">self</span>];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.buttonFirst</span> pointInside:btnPointInA withEvent:event]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.buttonFirst</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，返回默认处理</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> hitTest:point withEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12，GCD同步">12，GCD同步</h4><p>如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">dispatch_group_async(group, queue, ^&#123; <span class="comment">/*加载图片1 */</span> &#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123; <span class="comment">/*加载图片2 */</span> &#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123; <span class="comment">/*加载图片3 */</span> &#125;); </span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// 合并图片</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="13，NSOperation的特点">13，NSOperation的特点</h4><p><strong>依赖：</strong>顾名思义，第一个方法用于添加依赖，第二个方法则用于移除依赖。需要特别注意的是，用<code>addDependency:</code>方法添加的依赖关系是单向的，比如<code>[A addDependency:B];</code>，表示 A 依赖 B，B 并不依赖 A ；</p>
<p><strong>暂停：</strong>如果我们想要暂停和恢复执行 operation queue 中的 operation ，可以通过调用 operation queue 的 setSuspended: 方法来实现这个目的。不过需要注意的是，暂停执行 operation queue 并不能使正在执行的 operation 暂停执行，而只是简单地暂停调度新的 operation 。另外，我们<strong>并不能单独地暂停执行一个 operation</strong> ，除非直接 cancel 掉；</p>
<p><strong>优先级：</strong> 我们只能够在执行一个 operation 或将其添加到 operation queue 前，通过 operation 的 <code>setThreadPriority:</code> 方法来修改它的线程优先级。当 operation 开始执行时，NSOperation 类中默认的 <code>start</code> 方法会使用我们指定的值来修改当前线程的优先级。另外，我们指定的这个线程优先级只会影响 <code>main</code> 方法执行时所在线程的优先级。所有其它的代码，包括 operation 的 completion block 所在的线程会一直以默认的线程优先级执行。因此，当我们自定义一个并发的 operation 类时，我们也需要在 <code>start</code> 方法中根据指定的值自行修改线程的优先级。</p>
<h4 id="14,_UITextView代理方法的使用">14, UITextView代理方法的使用</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)textViewShouldBeginEditing:(<span class="built_in">UITextView</span> *)textView;</span><br><span class="line">- (<span class="built_in">BOOL</span>)textViewShouldEndEditing:(<span class="built_in">UITextView</span> *)textView;</span><br><span class="line">- (<span class="keyword">void</span>)textViewDidBeginEditing:(<span class="built_in">UITextView</span> *)textView;</span><br><span class="line">- (<span class="keyword">void</span>)textViewDidEndEditing:(<span class="built_in">UITextView</span> *)textView;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)textView:(<span class="built_in">UITextView</span> *)textView shouldChangeTextInRange:(<span class="built_in">NSRange</span>)range replacementText:(<span class="built_in">NSString</span> *)text;</span><br><span class="line">- (<span class="keyword">void</span>)textViewDidChange:(<span class="built_in">UITextView</span> *)textView;</span><br><span class="line">- (<span class="keyword">void</span>)textViewDidChangeSelection:(<span class="built_in">UITextView</span> *)textView;</span><br></pre></td></tr></table></figure>
<h4 id="15，如何把Model转换为字典">15，如何把Model转换为字典</h4><p>通过runtime的方式：</p>
<ul>
<li><p>首先，可以通过<code>class_copyPropertyList</code> 和 <code>protocol_copyPropertyList</code>方法来获取类的属性；  </p>
</li>
<li><p>比如获取某个类（obj）的属性列表：  </p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> propsCount;</span><br><span class="line">objc_property_t *props = class_copyPropertyList([obj class], &amp;propsCount);</span><br></pre></td></tr></table></figure>
<ul>
<li>通过property_getName方法就可以得到某个类属性的名字了</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> propsCount;</span><br><span class="line">objc_property_t *props = class_copyPropertyList([obj class], &amp;propsCount);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; propsCount; i++)&#123;    </span><br><span class="line">  objc_property_t prop = props[i];    </span><br><span class="line">  <span class="built_in">NSString</span> *propName = [<span class="built_in">NSString</span> stringWithUTF8String:property_getName(prop)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>得到类属性的名称后，就可以知道该属性对应的类型了，如果是Object-C class，直接判断数据类型即可，比如NSString、NSArray、NSDictionary等。如果该属性的值对应的是派生类，则需要回到上一步重新解析，直到遍历完为止</li>
</ul>
<h4 id="16，常用的SVN/Git操作">16，常用的SVN/Git操作</h4><ul>
<li><p>SVN 分支与tag  </p>
<p><a href="https://www.baidu.com/s?wd=SVN&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y3PA7bP1mvrj99uH61rHT10ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6K1TL0qnfK1TL0z5HD0IgF_5y9YIZ0lQzqlpA-bmyt8mh7GuZR8mvqVQL7dugPYpyq8Q1n1Pjc1nWRvPs" target="_blank" rel="external">SVN</a>官方推荐在一个版本库的根目录下先建立trunk、branches、tags这三个文件夹，其中trunk是开发主干，存放日常开发的内容；branches存放各分支的内容，比如为不同客户定制的不同版本；tags存放某个版本状态的标签，比如验收测试版、1.0.3版等。tags中的内容是存放不再修改的，tags通常只给管理员开放写权限。</p>
</li>
<li><p>SVN 回滚  </p>
<p>1). 改动没有被提交:直接svn revert something就行了；当something为目录时，需要加上参数-R(Recursive,递归)，否则只会将something这个目录的改动。   </p>
<p>2). 改动已经被提交:可以使用svn diff -r HEAD:2500 [something]，此处的something可以是文件、目录或整个项目。如果需要回滚到版本号2500：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn merge -r HEAD:<span class="number">2500</span> something</span><br></pre></td></tr></table></figure>
<h4 id="17，APNS_、IAP、itms-services协议等">17，APNS 、IAP、itms-<em>services</em>协议等</h4><ul>
<li>询问关于推送、应用内付费以及企业帐号发布等知识；</li>
<li>对AppFlyer、Adhoc、iTunes connect等了解使用情况。</li>
</ul>
<h4 id="18，算法题">18，算法题</h4><p>1). 四个人夜间要过一座桥，每人走路速度不一样，过桥需要时间分别是1，2，5，10分钟。现在只有一只手电筒在过桥时必须带，同时只能两人过，如何安排能够让四人最快速度过桥？</p>
<p>2). 25匹马赛跑，每次只能跑5匹，最快能赛几次找出跑得最快的3匹马？</p>
<h4 id="19，编码规范">19，编码规范</h4><p>不规范：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    UserSex_Man,</span><br><span class="line">    UserSex_Woman,</span><br><span class="line">&#125;UserSex;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">testA</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) UserSex sex;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">id</span>)initUserModelWithUserName: (<span class="built_in">NSString</span>*)name withAge:(<span class="keyword">int</span>)age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doLogIn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>修改后：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, TSTUserSexType) &#123;</span><br><span class="line">    TSTUserSexTypeMan,</span><br><span class="line">    TSTUserSexTypeWoman,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">testA</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span>       *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span> ,<span class="keyword">assign</span>) <span class="keyword">int</span>            age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) TSTUserSexType sex;</span><br><span class="line"></span><br><span class="line">- (instancetype)initUserModelWithUserName:(<span class="built_in">NSString</span>*)name withUserAge:(<span class="keyword">int</span>)age;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doLoginWithSuccess:(<span class="keyword">void</span>(^)(<span class="keyword">id</span> response))success</span><br><span class="line">                   failure:(<span class="keyword">void</span>(^)(<span class="built_in">NSError</span> *error))failure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<h3 id="三、高级篇">三、高级篇</h3><h4 id="20，Autorelease对象什么时候释放？">20，Autorelease对象什么时候释放？</h4><p>对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。那什么是一个Runloop呢？ 一个UI事件，Timer call， delegate call， 都会是一个新的Runloop。</p>
<p>Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop。</p>
<h4 id="21，深入理解runloop">21，深入理解runloop</h4><p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，这种模型通常被称作 <a href="http://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="external">Event Loop</a>。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。</p>
<p>RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p>
<p>OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>
<p>问题一：NSURLConnection或NSStream指定RunLoop Mode的原因？<br>问题二：为何NSTimer在界面滚动时无响应？</p>
<p>参考回答一：<br>如果是在主线程，那么在滚动ScrollView或者TableView时，主线程的Run Loop会运行在UITrackingRunLoopMode模式，那么NSURLConnection或者NSStream的回调就无法运行，设置为NSRunLoopCommonModes，都可以保证NSURLConnection或者NSStream的回调可以被调用。<br>参考回答二：<br>当用户触摸界面时，主线程的run loop不再对timer事件进行处理。解决办法如下：<br><code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</code></p>
<p>参考：<a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">http://blog.ibireme.com/2015/05/18/runloop/</a></p>
<h4 id="22，runtime的理解与使用">22，runtime的理解与使用</h4><p>场景一：运行时给category添加属性，比如<code>objc_getAssociatedObject</code>、<code>objc_setAssociatedObject</code>；<br>场景二：动态获取类属性名称，比如<code>class_copyPropertyList</code>；<br>场景三：消息转发：<br>第一步：动态方法解析<br>对象在接收到未知的消息时，首先会调用所属类的类方法 +resolveInstanceMethod: 或者 +resolveClassMethod:，前者处理实例方法调用，后者处理类方法调用。我们可以它们里面用 class_addMethod() 加入异常处理的方法，不过前提是我们以及实现了处理方法。<br>第二步：备用接收者<br>如果在第一步还是无法处理消息，则 Runtime 会继续调以下方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure></p>
<p>如果一个对象实现了这个方法，并返回一个非 nil 的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是 self 自身，否则就会出现无限循环。当然，如果我们没有指定相应的对象来处理 aSelector，则应该调用父类的实现来返回结果。<br>第三步：完整转发<br>如果第二步：备用接收者还是未能处理好消息，那么接下来只有启用完整的消息转发机制了，这时候会调用以下方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br></pre></td></tr></table></figure></p>
<p>运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。对象会创建一个表示消息的 NSInvocation 对象，把与尚未处理的消息有关的全部细节都封装在 anInvocation 中，包括：selector、目标(target)和参数。我们可以在 -forwardInvocation: 方法中选择将消息转发给其它对象。完整实例如下：<br>ViewController示例代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line"><span class="preprocessor">#pragma clang diagnostic push</span></span><br><span class="line"><span class="preprocessor">#pragma clang diagnostic ignored <span class="title">"-Wundeclared-selector"</span></span></span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(unknownMethod)];</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(unknownMethod2)];</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(unknownMethod3)];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(sel);</span><br><span class="line">    <span class="keyword">if</span> ([selectorString isEqualToString:<span class="string">@"unknownMethod"</span>]) &#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span><span class="variable">.class</span>, <span class="keyword">@selector</span>(unknownMethod), (IMP) dealWithExceptionForUnknownMethod, <span class="string">"v@:"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deal with unknownMethod.</span></span><br><span class="line"><span class="keyword">void</span> dealWithExceptionForUnknownMethod(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@, %p"</span>, <span class="keyword">self</span>, _cmd); <span class="comment">// Print: &lt;ViewController: 0x7ff96be33e60&gt;, 0x1078259fc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deal with unknownMethod2.</span></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(aSelector);</span><br><span class="line">    <span class="keyword">if</span> ([selectorString isEqualToString:<span class="string">@"unknownMethod2"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [[RuntimeMethodHelper alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deal with unknownMethod3.</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">    <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([RuntimeMethodHelper instancesRespondToSelector:aSelector]) &#123;</span><br><span class="line">            signature = [RuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="keyword">if</span> ([RuntimeMethodHelper instancesRespondToSelector:anInvocation<span class="variable">.selector</span>]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:[[RuntimeMethodHelper alloc] init]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RuntimeMethodHelper示例代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*RuntimeMethodHelper.h*/</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RuntimeMethodHelper</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)unknownMethod2;</span><br><span class="line">- (<span class="keyword">void</span>)unknownMethod3;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*RuntimeMethodHelper.m*/</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RuntimeMethodHelper</span></span></span><br><span class="line">- (<span class="keyword">void</span>)unknownMethod2 &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@, %p"</span>, <span class="keyword">self</span>, _cmd); <span class="comment">// Print: &lt;RuntimeMethodHelper: 0x7fb61042f410&gt;, 0x10170d99a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)unknownMethod3 &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@, %p"</span>, <span class="keyword">self</span>, _cmd); <span class="comment">// Print: &lt;RuntimeMethodHelper: 0x7f814b498ee0&gt;, 0x102d79929</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>场景四：动态创建类和对象，例如：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类实例</span></span><br><span class="line"><span class="keyword">id</span> class_createInstance ( Class cls, size_t extraBytes );</span><br><span class="line"><span class="comment">// 在指定位置创建类实例</span></span><br><span class="line"><span class="keyword">id</span> objc_constructInstance ( Class cls, <span class="keyword">void</span> *bytes );</span><br><span class="line"><span class="comment">// 销毁类实例</span></span><br><span class="line"><span class="keyword">void</span> * objc_destructInstance ( <span class="keyword">id</span> obj );</span><br></pre></td></tr></table></figure></p>
<p>场景五：IOS中如何Hook消息？<br><code>class_replaceMethod</code>使用该函数可以在运行时动态替换某个类的函数实现，截获系统类的某个实例函数。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">IMP orginIMP;</span><br><span class="line"><span class="built_in">NSString</span> * MyUppercaseString(<span class="keyword">id</span> SELF, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"begin uppercaseString"</span>);</span><br><span class="line">    <span class="built_in">NSString</span> *str = orginIMP (SELF, _cmd);（<span class="number">3</span>）</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"end uppercaseString"</span>);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">-（<span class="keyword">void</span>）testReplaceMethod</span><br><span class="line">&#123;</span><br><span class="line">      Class strcls = [<span class="built_in">NSString</span> class];</span><br><span class="line">      SEL  oriUppercaseString = <span class="keyword">@selector</span>(uppercaseString);</span><br><span class="line">      orginIMP = [<span class="built_in">NSStringinstanceMethodForSelector</span>:oriUppercaseString];  （<span class="number">1</span>）  </span><br><span class="line">      IMP imp2 = class_replaceMethod(strcls,oriUppercaseString,(IMP)MyUppercaseString,<span class="literal">NULL</span>);（<span class="number">2</span>）</span><br><span class="line">      <span class="built_in">NSString</span> *s = <span class="string">"hello world"</span>;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[s uppercaseString]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span><br><span class="line">执行结果为:</span><br><span class="line">begin uppercaseString</span><br><span class="line">end uppercaseString</span><br><span class="line">HELLO WORLD</span><br><span class="line">这段代码的作用就是</span><br><span class="line">（1）得到uppercaseString这个函数的函数指针存到变量orginIMP中</span><br><span class="line">（2）将NSString类中的uppercaseString函数的实现替换为自己定义的MyUppercaseString</span><br><span class="line">（3）这样每次对NSString调用uppercaseString的时候，都会打印出log来</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>场景六：Method Swizzling<br>例如，我们想跟踪在程序中每一个view controller展示给用户的次数，在每个view controller的viewDidAppear中添加跟踪代码，但是这太过麻烦。这种情况下，我们就可以使用Method Swizzling。示例代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Tracking</span>) </span></span><br><span class="line"> </span><br><span class="line">+ (<span class="keyword">void</span>)load &#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; </span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; </span><br><span class="line">        Class aClass = [<span class="keyword">self</span> class]; </span><br><span class="line"> </span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:); </span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(xxx_viewWillAppear:); </span><br><span class="line"> </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(aClass, originalSelector); </span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// When swizzling a class method, use the following:</span></span><br><span class="line">        <span class="comment">// Class aClass = object_getClass((id)self);</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// Method originalMethod = class_getClassMethod(aClass, originalSelector);</span></span><br><span class="line">        <span class="comment">// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);</span></span><br><span class="line"> </span><br><span class="line">        <span class="built_in">BOOL</span> didAddMethod = </span><br><span class="line">            class_addMethod(aClass, </span><br><span class="line">                originalSelector, </span><br><span class="line">                method_getImplementation(swizzledMethod), </span><br><span class="line">                method_getTypeEncoding(swizzledMethod)); </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (didAddMethod) &#123; </span><br><span class="line">            class_replaceMethod(aClass, </span><br><span class="line">                swizzledSelector, </span><br><span class="line">                method_getImplementation(originalMethod), </span><br><span class="line">                method_getTypeEncoding(originalMethod)); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#pragma mark - Method Swizzling </span></span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123; </span><br><span class="line">    [<span class="keyword">self</span> xxx_viewWillAppear:animated]; </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"viewWillAppear: %@"</span>, <span class="keyword">self</span>); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<h4 id="23，lib库的编写与使用">23，lib库的编写与使用</h4><ul>
<li>如何保证lib库中category文件的正常读取？  </li>
<li>如何保证lib对armv7s的支持？<br>Build Setting -&gt; Architectures, 添加 $(ARCHS_STANDARD)和   armv7s</li>
<li>如何合并不同平台的lib库？</li>
<li>iOS 第三方库冲突的如何处理？可以对lib库内的文件修改重修打包吗 ？<br>实例，比如libHChatSDK.a中包含了JSONKit库，现有工程中同样包含了JSONKit库，这样在当前工程中加入libHChatSDK.a时会引起duplicate symbols for architecture armv7的编译错误，那么我们可以重新编辑libHChatSDK.a，删除JSONKit.o然后再打包合并即可，具体命令如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1,新建armv7s目录</span></span><br><span class="line">mkdir ~/desktop/armv7s</span><br><span class="line"><span class="comment"># 2,分离出armv7s平台</span></span><br><span class="line">lipo  libHChatSDK.a  -thin  armv7s  -output  libHChatSDK-armv7s.a</span><br><span class="line"><span class="comment"># 3,解压 libHChatSDK.a</span></span><br><span class="line"><span class="built_in">cd</span> armv7s &amp;&amp; ar xv libHChatSDK-armv7s.a</span><br><span class="line"><span class="comment"># 4,查看库中所包含的文件列表</span></span><br><span class="line">ar -t armv7/libHChatSDK-armv7s.a</span><br><span class="line"><span class="comment"># 5,找到JSONKit.o并删除</span></span><br><span class="line">rm JSONKit.o</span><br><span class="line"><span class="comment"># 6,重新打包libHChatSDK-armv7s.a</span></span><br><span class="line">ar rcs libHChatSDK-armv7s.a armv7s/*.o</span><br><span class="line"><span class="comment"># 7,重复第3步，确认JSONKit已经被删除</span></span><br><span class="line"><span class="comment"># 8,按照1-7分别生成armv7平台、arm64平台及模拟器使用的x86_64、i386平台</span></span><br><span class="line"><span class="comment"># 9,最后用lipo -c 命令合并各个平台即可</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>常用的lib命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用 lipo info 查看静态库支持的平台</span></span><br><span class="line">$ lipo libname.a -info</span><br><span class="line"><span class="comment"># 用 lipo remove 参数来删除平台</span></span><br><span class="line">lipo libname.a -remove x86_64 -output libname1.a</span><br><span class="line"><span class="comment"># 用 lipo create 将两个不同平台的库合并到一起</span></span><br><span class="line">$ lipo -create libname1.a libname2.a -output libname3.a</span><br><span class="line"><span class="comment"># 用 lipo thin 参数来分离平台</span></span><br><span class="line">lipo libname.a -thin armv7 -output armv7/libname-armv7.a</span><br></pre></td></tr></table></figure></p>
<h4 id="24，ARM64与ARMv7">24，ARM64与ARMv7</h4><p>Arm处理器，因为其低功耗和小尺寸而闻名，几乎所有的手机处理器都基于arm，其在嵌入式系统中的应用非常广泛，它的性能在同等功耗产品中也很出色。</p>
<p>Armv6、armv7、armv7s、arm64都是arm处理器的指令集，所有指令集原则上都是向下兼容的，如iPhone4S的CPU默认指令集为armv7指令集，但它同时也兼容armv6指令集，只是使用armv6指令集时无法充分发挥其性能，即无法使用armv7指令集中的新特性，同理，iPhone5的处理器标配armv7s指令集，同时也支持armv7指令集，只是无法进行相关的性能优化，从而导致程序的执行效率没那么高。 </p>
<p>需要注意的是iOS模拟器没有运行arm指令集，编译运行的是x86指令集，所以，只有在iOS设备上，才会执行设备对应的arm指令集。</p>
<p>iOS设备与ARM平台分布如下图：</p>
<p><img src="http://7xkptx.com1.z0.glb.clouddn.com/armv7s.png" alt=""></p>
<h4 id="参考：">参考：</h4><p><a href="http://www.jianshu.com/p/2e7ae4457083" target="_blank" rel="external">http://www.jianshu.com/p/2e7ae4457083</a></p>
<p><a href="http://www.iswifting.com/2015/07/26/71/" target="_blank" rel="external">http://www.iswifting.com/2015/07/26/71/</a></p>
<p><a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="external">http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/24/ iOS面试总结/" data-id="cijdtvvto0000nyb1tc2g5dnc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-几款mac小工具推荐" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/14/几款mac小工具推荐/" class="article-date">
  <time datetime="2015-12-14T09:30:00.000Z" itemprop="datePublished">2015-12-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mac/">mac</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/14/几款mac小工具推荐/">几款mac小工具推荐</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="iTerm2">iTerm2</h3><p>Mac下的命令行工具五花八门，选择一款便捷的扩展性强的工具对工作效率提升十分重要。在此推荐<a href="https://www.iterm2.com/" target="_blank" rel="external">iTem2</a> + <a href="http://ohmyz.sh/" target="_blank" rel="external">oh-my-zsh</a>，Mac自带的shell工具Terminal是基于bash实现，而且zsh在兼容bash的基础上又提供了强大的扩展插件，二者方便切换，只需一条命令即可：exec bash（切换bash），exec zsh（切换zsh）。oh my zsh是一款<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="external">开源</a>的ZSH插件，可以方便的自定义主题，对SVN/GIT有很好的支持，有强大的<a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins" target="_blank" rel="external">开源开源插件</a>，如<a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/autojump" target="_blank" rel="external">autojump</a>，<a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/svn" target="_blank" rel="external">svn</a>等提供支持。附图如下：</p>
<p><img src="http://7xkptx.com1.z0.glb.clouddn.com/f334t443h56j76.png" alt=""></p>
<p>快捷键配置如下：</p>
<p><img src="http://7xkptx.com1.z0.glb.clouddn.com/96339610-C393-4D03-A7AF-BB1120C80B8A.png" alt=""></p>
<ul>
<li>设置Left option 为 +Esc，可以单词为单位左右移动光标：向后 Option + B(back) ; 向前 Option + F(front) </li>
<li>Option + Q 清除当前行</li>
<li>Command + K 清除当前面板</li>
<li>Option + P 上一个输入过的命令</li>
<li>Option + N 后一个输入过的命令</li>
<li>向上箭头 ：上一个执行过的命令</li>
<li>向下剪头 ：后一个执行过的命令</li>
<li>Control + A 光标最前</li>
<li>Control + E 光标最后</li>
</ul>
<h3 id="aTEXT"><a href="https://itunes.apple.com/us/app/atext/id488566438?mt=12" target="_blank" rel="external">aTEXT</a></h3><p>经常使用命令行的同学，有时不得不重复一些常用命令，比如代码的提交、更新，API的测试等，aText就是一款提供命令行或常用语句缩写的工具。</p>
<p><img src="http://7xkptx.com1.z0.glb.clouddn.com/Screen%20Shot%202015-12-14%20at%2016.39.17.png" alt=""></p>
<h3 id="Hexo"><a href="https://hexo.io/" target="_blank" rel="external">Hexo</a></h3><p>hero是一款极为方便的基于nodejs的静态博客工具，只需几行命令即可搞定，具体请参考<a href="https://hexo.io/" target="_blank" rel="external">这里</a>。hexo还支持一键发布到GitHub Pages, Heroku 或其他网站，另外官方推出诸多插件，比如<a href="https://github.com/jaredly/hexo-admin" target="_blank" rel="external">hexo-admin</a>后台管理可以方便的添加tag、分类等。</p>
<h3 id="其他">其他</h3><p>比如常用的markdown编辑器<a href="typora.io/">Typara</a>，效率工具<a href="https://pomotodo.com/" target="_blank" rel="external">番茄土豆</a>，以及<a href="https://pomotodo.com/" target="_blank" rel="external">奇妙清单</a>等对工作效率的提升也有很大帮助。更多请关注来自知乎的<a href="http://www.zhihu.com/question/20873070" target="_blank" rel="external">热门推荐</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/14/几款mac小工具推荐/" data-id="cijdtvvuj0009nyb1zay1sol6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mac/">mac</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-常用的SVN命令小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/10/常用的SVN命令小结/" class="article-date">
  <time datetime="2015-11-10T12:06:00.000Z" itemprop="datePublished">2015-11-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/svn/">svn</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/10/常用的SVN命令小结/">常用的SVN命令小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1，基础命令">1，基础命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">svn co repository_url // check out respoitory</span><br><span class="line">svn ci -m <span class="string">"your comments"</span> // commit files</span><br><span class="line">svn up repository_url // update files</span><br></pre></td></tr></table></figure>
<h3 id="2，branch_&amp;_tag">2，branch &amp; tag</h3><p>所谓打tag，要从<a href="https://www.baidu.com/s?wd=SVN&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y3PA7bP1mvrj99uH61rHT10ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6K1TL0qnfK1TL0z5HD0IgF_5y9YIZ0lQzqlpA-bmyt8mh7GuZR8mvqVQL7dugPYpyq8Q1n1Pjc1nWRvPs" target="_blank" rel="external">SVN</a>官方推荐的目录结构说起了。<a href="https://www.baidu.com/s?wd=SVN&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y3PA7bP1mvrj99uH61rHT10ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6K1TL0qnfK1TL0z5HD0IgF_5y9YIZ0lQzqlpA-bmyt8mh7GuZR8mvqVQL7dugPYpyq8Q1n1Pjc1nWRvPs" target="_blank" rel="external">SVN</a>官方推荐在一个版本库的根目录下先建立trunk、branches、tags这三个文件夹，其中trunk是开发主干，存放日常开发的内容；branches存放各分支的内容，比如为不同客户定制的不同版本；tags存放某个版本状态的标签，比如验收测试版、1.0.3版等。branhces和tags本质没有区别，都是通过<a href="https://www.baidu.com/s?wd=svn&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y3PA7bP1mvrj99uH61rHT10ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6K1TL0qnfK1TL0z5HD0IgF_5y9YIZ0lQzqlpA-bmyt8mh7GuZR8mvqVQL7dugPYpyq8Q1n1Pjc1nWRvPs" target="_blank" rel="external">svn</a> copy方式建立的，差异在于通常branches中的内容是需要继续修改或开发的，tags中的内容是存放不再修改的，这一般通过权限设置来解决，tags通常只给管理员开放写权限。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 新建分支</span><br><span class="line">svn copy master_repository_url branch_repository_url -m <span class="string">"your comments"</span></span><br><span class="line"></span><br><span class="line">// 新建空白分支</span><br><span class="line">svn mkdir branch_repository_url</span><br><span class="line"></span><br><span class="line">// 删除分支</span><br><span class="line">svn rm branch_repository_url -m <span class="string">"your comments"</span></span><br><span class="line"></span><br><span class="line">// 新建tag</span><br><span class="line">svn copy master_repository_url tag_repository_url -m <span class="string">"your comments"</span></span><br><span class="line"></span><br><span class="line">// 删除tag</span><br><span class="line">svn rm tag_repository_url -m <span class="string">"your comments"</span></span><br><span class="line"></span><br><span class="line">// 查看branches</span><br><span class="line">svn ls ^/branches --verbose</span><br></pre></td></tr></table></figure>
<h3 id="3，回滚">3，回滚</h3><p>3-1），改动没有被提交</p>
<p>这种情况下，使用svn revert就能取消之前的修改。svn revert用法如下：当something为单个文件时，直接svn revert something就行了；当something为目录时，需要加上参数-R(Recursive,递归)，否则只会将something这个目录的改动。</p>
<p>3-2），改动已经被提交</p>
<p>这种情况下，用svn merge命令来进行回滚。先运行svn up保证拿到最新的版本，然后svn log查看并找到要回滚的版本号，如果想要更详细的了解情况，可以使用svn diff -r HEAD:2500 [something]，此处的something可以是文件、目录或整个项目。</p>
<p>如果需要回滚到版本号2500：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn merge -r HEAD:<span class="number">2500</span> something</span><br></pre></td></tr></table></figure>
<p>为了保险起见，再次确认回滚的结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn diff -r HEAD:<span class="number">2500</span> [something]</span><br></pre></td></tr></table></figure>
<p>发现无误，提交即可。</p>
<p>3-3），分支与主干的合并：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分支合到主干 cd trunk</span></span><br><span class="line">svn merge -r &lt;revision <span class="built_in">where</span> branch was cut&gt;:&lt;revision of trunk&gt; svn://branch/path</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分支当前版本为4847，想把4825到4847间的改动merge到主干</span></span><br><span class="line"><span class="comment"># cd trunk</span></span><br><span class="line">svn merge -r <span class="number">4825</span>:<span class="number">4847</span> svn://branch/path</span><br><span class="line">svn ci -m <span class="string">"merge branch changes r4835:4847 into trunk"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主干合到分支 cd branch</span></span><br><span class="line"><span class="comment"># 在r23创建了一个分支，trunk版本号更新到了25，想把23-25之间的改动merge到分支</span></span><br><span class="line">svn merge -r <span class="number">23</span>:<span class="number">25</span> svn://trunk/path</span><br><span class="line">svn ci -m <span class="string">"merge trunk changes r23:25 into my branch"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cd trunk</span></span><br><span class="line"><span class="comment"># 查看当前Branch中已经有那些改动已经被合并到Trunk中</span></span><br><span class="line">svn mergeinfo svn://branch/path</span><br><span class="line"></span><br><span class="line"><span class="comment"># cd trunk</span></span><br><span class="line"><span class="comment"># 查看Branch中那些改动还未合并</span></span><br><span class="line">svn merginfo svn://branch/path --show-revs eligible</span><br></pre></td></tr></table></figure>
<p>3-4），merge分支B到分支A</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">step1: Checkout URL A</span><br><span class="line">       <span class="comment"># cd branch A</span></span><br><span class="line">step2: merge URL B to your working copy of A</span><br><span class="line">       svn merge -r <span class="number">10</span>:HEAD http://branch-b .</span><br><span class="line">step3: Commit A</span><br></pre></td></tr></table></figure>
<h3 id="4，冲突提示">4，冲突提示</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(p) postpone          暂时推后处理，我可能要和那个和我冲突的家伙商量一番</span><br><span class="line">(df) diff-full        把所有的修改列出来，比比看</span><br><span class="line">(e) edit              直接编辑冲突的文件</span><br><span class="line">(mc) mine-conflict    如果你很有自信可以只用你的修改，把别人的修改干掉</span><br><span class="line">(tc) theirs-conflict  底气不足，还是用别人修改的吧</span><br><span class="line">(s) show all options  显示其他可用的命令</span><br></pre></td></tr></table></figure>
<h3 id="5，svn符号">5，svn符号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">U:表示从服务器收到文件更新了</span><br><span class="line">G:表示本地文件以及服务器文件都已更新,而且成功的合并了 </span><br><span class="line">其他的如下:</span><br><span class="line">A:表示有文件或者目录添加到工作目录</span><br><span class="line">R:表示文件或者目录被替换了.</span><br><span class="line">C:表示文件的本地修改和服务器修改发生冲突</span><br></pre></td></tr></table></figure>
<h3 id="6，patch">6，patch</h3><p>有时同事A做的修改需要同事B去Review，同事C去提交。使用patch工具可以很好的决代码传递。<br>6-1).生成patch:<br>同事 A 运行如下命令生成 patch:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn diff &gt; aaa.patch</span><br></pre></td></tr></table></figure></p>
<p>6-2).应用patch:<br>同事 B 运行如下命令应用 patch:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch –p0 &lt; aaa.patch</span><br></pre></td></tr></table></figure></p>
<p>6-3).去除patch，恢复旧版本<br>当他 review 完代码，想删除该 patch 时， 可运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -RE -p0 &lt; aaa.patch</span><br></pre></td></tr></table></figure></p>
<p>-p0，是“当前路径”<br>-p1，是“上一级路径”</p>
<p>参考：<a href="http://stereointeractive.com/blog/2009/02/17/svn-merge-trunk-changes-to-your-branch/" target="_blank" rel="external">http://stereointeractive.com/blog/2009/02/17/svn-merge-trunk-changes-to-your-branch/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/11/10/常用的SVN命令小结/" data-id="cijdtvvuh0004nyb1xop7hoy1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/svn/">svn</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-APNS测试与部署" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/09/APNS测试与部署/" class="article-date">
  <time datetime="2015-11-09T07:27:00.000Z" itemprop="datePublished">2015-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/09/APNS测试与部署/">APNS测试与部署</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>APNS</strong>即Apple Push Notification Service，中文翻译为苹果推送通知服务。特点是稳定、方便，不足是没有送达结果的统计，所以衍生了针对此服务的第三方推送。比如<a href="https://developer.apple.com/app-store/review/guidelines/" target="_blank" rel="external">极光推送</a>、<a href="https://leancloud.cn/docs/ios_push_cert.html" target="_blank" rel="external">leancloud</a>等，很大程度上减少了服务端的开发量。本文主要介绍APNS的开发调试及部署上线的流程。客户端准备工作如下：</p>
<h3 id="创建Certificates">创建Certificates</h3><p>进入<a href="https://developer.apple.com/account/ios/identifiers/bundle/bundleList.action" target="_blank" rel="external">苹果开发者中心</a>，打开App IDs，找到Xcode工程对应的Bundle ID，即可看到Push Notifications选项开发与生产配置分别为Configurable，点击Edit，进入下一步Create Certificate，如下图所示。</p>
<p><img src="http://7xkptx.com1.z0.glb.clouddn.com/234gwhh54.png" alt=""></p>
<p><img src="http://7xkptx.com1.z0.glb.clouddn.com/e2f3gwerh65.png" alt=""></p>
<p>生成Cer文件的过程中需要本地生成一个.certSigningRequest文件上传</p>
<p><img src="http://7xkptx.com1.z0.glb.clouddn.com/1ntf3qwf34.png" alt=""></p>
<h3 id="如何生成_Certificate_Signing_Request">如何生成 Certificate Signing Request</h3><p>打开mac系统中的Keychain，在证书助理中选择从证书颁发机构请求证书，填写邮箱保存本地即可。如下图：</p>
<p><img src="http://7xkptx.com1.z0.glb.clouddn.com/1f4h4e5j6ju6.png" alt=""></p>
<p><img src="http://7xkptx.com1.z0.glb.clouddn.com/2fwgrrh5.png" alt=""></p>
<p>生成CSR文件后上传，即可生成Developerment版的cer证书，下载证书到本地，双击安装到钥匙串中，然后打开钥匙串找到刚在安装的cer证书，点击导出，选择个人信息交换(.p12)格式。</p>
<p><img src="http://7xkptx.com1.z0.glb.clouddn.com/4bertnr6jutyk.png" alt=""></p>
<p>完成上述操作后，打开终端，进入p12文件所在文件夹，执行以下命令，生成服务端push所用的pem证书就可以了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -in XXX.p12 -out XXX.pem -nodes</span><br></pre></td></tr></table></figure>
<p>查看证书有效期：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -in xxx.pem -noout -dates</span><br></pre></td></tr></table></figure></p>
<p>返回结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notBefore=Nov  <span class="number">6</span> <span class="number">07</span>:<span class="number">55</span>:<span class="number">33</span> <span class="number">2015</span> GMT</span><br><span class="line">notAfter=Nov  <span class="number">5</span> <span class="number">07</span>:<span class="number">55</span>:<span class="number">33</span> <span class="number">2016</span> GMT</span><br></pre></td></tr></table></figure></p>
<p>连接APNS测试证书是否合法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Development 环境</span><br><span class="line">openssl s_client -connect gateway.sandbox.push.apple.com:<span class="number">2195</span> -cert xxx.pem -key xxx.pem </span><br><span class="line">// Distribution 环境</span><br><span class="line">openssl s_client -connect gateway.push.apple.com:<span class="number">2195</span> -cert xxx.pem -key xxx.pem</span><br></pre></td></tr></table></figure></p>
<p>合法返回结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Protocol  : TLSv1</span><br><span class="line">Cipher    : AES256-SHA</span><br><span class="line">Session-ID:</span><br><span class="line">Session-ID-ctx:</span><br><span class="line">Master-Key: <span class="number">30</span>AF233C50CBEB51B7358BA47E6B4D556CC962BC288F6D51E68300D86400F927925077B5B90C4938B189146E0A4897B2</span><br><span class="line">Key-Arg   : None</span><br><span class="line">Start Time: <span class="number">1446972326</span></span><br><span class="line">Timeout   : <span class="number">300</span> (sec)</span><br><span class="line">Verify <span class="built_in">return</span> code: <span class="number">0</span> (ok)</span><br></pre></td></tr></table></figure></p>
<h3 id="如何测试">如何测试</h3><p>Developer环境下的测试推荐一个mac上的app，<a href="https://github.com/Zambiorix/Cocoa-APNS-Test" target="_blank" rel="external">Cocoa-APNS-Test</a>，部署简单方便。Production环境下的测试则需要Adhoc证书的支持了，具体操作请参考<a href="https://segmentfault.com/a/1190000000624185" target="_blank" rel="external">这里</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/11/09/APNS测试与部署/" data-id="cijdtvvup000onyb1i0fbgt1q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/推送/">推送</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS应用内付费(IAP)提交审核一波三折" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/19/iOS应用内付费(IAP)提交审核一波三折/" class="article-date">
  <time datetime="2015-09-19T07:00:00.000Z" itemprop="datePublished">2015-09-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/App-Store/">App Store</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/19/iOS应用内付费(IAP)提交审核一波三折/">iOS应用内付费(IAP)提交审核一波三折</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>App Store的审核众所周知是一个耗时耗力的活儿，尤其是第一个版本的提交，如果App又包含的内付费的功能，那就更需要耐心了。为期一个半月的审核终于通过，简单记录下期间的经验，希望能帮助到大家。</p>
<h4 id="首先汇总下被拒的官方回复：">首先汇总下被拒的官方回复：</h4><ul>
<li>2.2 - Apps that exhibit bugs will be rejected</li>
<li>2.9 - Apps that are “demo”, “trial”, or “test” versions will be rejected. Beta Apps may only be submitted through TestFlight and must follow the TestFlight guidelines</li>
<li>3.3 - Apps with names, descriptions, screenshots, or previews not relevant to the content and functionality of the App will be rejected</li>
<li>11.4 - Apps that use IAP to purchase credits or other currencies must consume those credits within the App</li>
<li>14.1 - Any App that is defamatory, offensive, mean-spirited, or likely to place the targeted individual or group in harm’s way will be rejected</li>
<li>14.3 - Apps that display user generated content must include a method for filtering objectionable material, a mechanism for users to flag offensive content, and the ability to block abusive users from the service</li>
<li>17.2 - Apps that require users to share personal information, such as email address and date of birth, in order to function will be rejected</li>
</ul>
<h4 id="针对以上问题的分析与解决：">针对以上问题的分析与解决：</h4><ul>
<li><p>2.2，苹果测试人员在审核期间会使用最新的iOS系统来测试应用，但不一定是最新的硬件。所以在提审之前要保证App在最新的系统下运行流畅，如果是iPhone的版本，也需要确保在iPad上不出问题才行。当时我们提交的时候官方最新的iOS版本是8.4.1，我们以为在8.4.0上运行没问题就好，忽略了iOS小版本的某些特性差异。</p>
</li>
<li><p>2.9，由于我们的App是做了日文的本地化，在首页banner图片上有细小的测试字样，提审的时候没有去除，苹果对这方面的审核非常严格，会认为你的产品当前仍处于测试版，所以不能上架。提醒开发者留意这些细节。</p>
</li>
<li><p>3.3，此项是关于iTunes Connect 中App介绍说明的，建议说明文案宁少勿多，不要涉及等等、更多字样，只列举明确包含的功能即可。</p>
</li>
<li><p>11.4，苹果关于IAP的规则是虚拟货币不可以在app内流通且只能在平台内消费，更不允许有送礼+分成等方式，关于收入的分成十分严格，请开发者谨慎对待。在产品初期制定好使用规则，不然以后改动成本巨大。</p>
</li>
<li><p>14.1/14.3，建议开发者对应用的评级有一个合理的定位，尤其是UGC、视频方面的App，在不清楚的情况下级别勾选越高越对审核有帮助。详细请参考<a href="https://developer.apple.com/app-store/review/guidelines/" target="_blank" rel="external">官方审核指南</a>。如果是UGC内容要有非常明显的举报入口，及一定范围内的敏感词过滤功能。</p>
</li>
<li><p>17.2，在App集成第三方登录时会经常遇到，苹果建议开发者有自己的帐号系统，如果是使用Facebook/Twitter/Weibo/Weixin做认证，除了拉取用户个人资料和分享，App必须包含显著的FB和TW特定账户功能。特定功能比如同步Feed至第三方系统，获取粉丝及关注列表等。针对此条款我们专门做了申诉，大家可以作为参考：</p>
<p>Sorry but I am afraid you misunderstood the function of our application. Actually wedo not force users to share personal information in order to function, we justpull our users’ profile information when they login from Facebook and Twitter.And for the account-based features from Facebook and Twitter, users can share streaming to The-third Party platform, andafter sharing success, there will be link on the-third Party platform  which can click and jump to our app. Userscan also share their clips to Facebook and Twitter and these message will besynchronized. we made screenshots to explain this functionality of ourapplication. I hope it works to help you know more about our app. </p>
<p>另外还配了应用内使用Facebook功能的配图，比如分享、同步Feed，最后才审核通过。下图为数次被拒的原因。</p>
</li>
</ul>
<p><img src="http://7xkptx.com1.z0.glb.clouddn.com/43g34h6.png" alt="Purchases"></p>
<h4 id="重点说一下IAP审核遇到的问题">重点说一下IAP审核遇到的问题</h4><ul>
<li>先说购买凭证的验证，在苹果审核期间只会再Sandbox环境购买，所以购买凭证需要链接苹果测试服务器（<a href="https://sandbox.itunes.apple.com/verifyReceipt" target="_blank" rel="external">https://sandbox.itunes.apple.com/verifyReceipt</a> ）来验证，等审核通过，后端部署到苹果正式服务器（<a href="https://buy.itunes.apple.com/verifyReceipt" target="_blank" rel="external">https://buy.itunes.apple.com/verifyReceipt</a>）即可。我们在这方面犯了一个错误就是在期间后段链接的是苹果的测试服务器造成购买失败，应用被拒绝。</li>
<li>如果应用被拒了一次，再次提交时的如果IAP商品的状态为Developer Action Needed（如下图所示），需要手动刷新下，编辑下商品名称，加个空格即可。然后状态会变为正在等待审核，再上传二进制文件。</li>
</ul>
<p><img src="http://7xkptx.com1.z0.glb.clouddn.com/f43thj4b53h235g5b.png" alt="Purchases"></p>
<h4 id="One_more_thing_-_合理申诉">One more thing - 合理申诉</h4><ul>
<li>如果应用被拒后，第一时间先确认是由于二进制文件的问题，还是文案的描述问题，或者是苹果审核团队的疑问未得到解答。如果是二进制文件被拒，则需要修复问题后重新打包上传，等待审核结果。</li>
</ul>
<ul>
<li>如果是提审文案或者配图的问题只需要修改下再次提交审核即可，无需二次打包。</li>
<li>还有一种情况是审核被拒，可以不做任何改动，直接申诉。在iTunes Connect解决方案中心会收到来自苹果审核团队的站内信，只需要详细逐条回复即可。最好绘声绘色，图文并茂，一般24小时内会得到苹果的二次确认。如果审核人员认可了你的申诉，那么你的App很快就会进入In Review的状态，离上架就只有一步之遥了。心酸经历附个图：</li>
</ul>
<p><img src="http://7xkptx.com1.z0.glb.clouddn.com/f2f32g43gwg.png" alt="Purchases"></p>
<h5 id="相关引用：">相关引用：</h5><p><a href="https://blog.coding.net/blog/ios-testFlight" target="_blank" rel="external">https://blog.coding.net/blog/ios-testFlight</a><br><a href="http://blog.devtang.com/blog/2013/04/07/tricks-in-iap/" target="_blank" rel="external">http://blog.devtang.com/blog/2013/04/07/tricks-in-iap/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/09/19/iOS应用内付费(IAP)提交审核一波三折/" data-id="cijdtvvun000jnyb16385tdab" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IAP/">IAP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-使用github发布ios应用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/05/使用github发布ios应用/" class="article-date">
  <time datetime="2015-09-05T11:18:00.000Z" itemprop="datePublished">2015-09-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/05/使用github发布ios应用/">使用Github发布iOS应用（OTA）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>OTA</strong> (Over The Air)是苹果很早就支持的功能，目的是让企业用户脱离Appstore通过网页来发布app，想要实现OTA发布，首页要购买一个企业证书，价格是$299/年。申请企业证书：<a href="https://developer.apple.com/programs/enterprise/" target="_blank" rel="external">https://developer.apple.com/programs/enterprise/</a></p>
<h5 id="发布流程如下：">发布流程如下：</h5><p><strong>1，使用Xcode生成ipa安装包</strong></p>
<ul>
<li>首先在TARGETS的General配置中，将Bundle Identifier设置为该企业帐号对应的App ID，如com.baidu.XXX；</li>
<li>然后在Build Setting的Code signing一栏，选择企业帐号对应的Distribution证书；</li>
<li>接下来选择Xcode-&gt;Product-&gt;Archive，即可开始打包了。</li>
<li>生成xcarchive，接下来Export时，需要选择Save for Enterprise Deployment一项，点击next即可导出ipa文件了。</li>
</ul>
<p><img src="http://7xkptx.com1.z0.glb.clouddn.com/giter5ty546j65ge.png" alt="Enterprise"></p>
<p><strong>2，将ipa、plist、html文件、icon上传至新建的根目录</strong></p>
<p>首先新建一个空白的github仓库，将打包好的ipa文件及空白install.plist、install.html文件及app Icon图片上传至仓库根目录。这样就有了每个文件在github上的链接地址。</p>
<p>然后配置install.plist文件如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">plist</span> <span class="attribute">version</span>=<span class="value">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">key</span>&gt;</span>items<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">key</span>&gt;</span>assets<span class="tag">&lt;/<span class="title">key</span>&gt;</span>   </span><br><span class="line">                              </span><br><span class="line">          <span class="tag">&lt;<span class="title">array</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="title">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="title">string</span>&gt;</span>software-package<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="title">key</span>&gt;</span>url<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="title">string</span>&gt;</span>https://***/XXX.ipa<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="title">dict</span>&gt;</span> </span><br><span class="line">                             </span><br><span class="line">              <span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">        		    <span class="tag">&lt;<span class="title">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">        			<span class="tag">&lt;<span class="title">string</span>&gt;</span>display-image<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">        			<span class="tag">&lt;<span class="title">key</span>&gt;</span>needs-shine<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">        			<span class="tag">&lt;<span class="title">true</span>/&gt;</span></span><br><span class="line">        			<span class="tag">&lt;<span class="title">key</span>&gt;</span>url<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">        			<span class="tag">&lt;<span class="title">string</span>&gt;</span>https://***/Icon57.png<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">        		<span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        		<span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">        			<span class="tag">&lt;<span class="title">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">        			<span class="tag">&lt;<span class="title">string</span>&gt;</span>full-size-image<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">        			<span class="tag">&lt;<span class="title">key</span>&gt;</span>needs-shine<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">        			<span class="tag">&lt;<span class="title">true</span>/&gt;</span></span><br><span class="line">        			<span class="tag">&lt;<span class="title">key</span>&gt;</span>url<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">        			<span class="tag">&lt;<span class="title">string</span>&gt;</span>https://***/Icon57.png<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">        		<span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="title">array</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">            <span class="tag">&lt;<span class="title">key</span>&gt;</span>metadata<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">            <span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">key</span>&gt;</span>bundle-identifier<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">string</span>&gt;</span>com.baidu.***<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">key</span>&gt;</span>bundle-version<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">string</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">string</span>&gt;</span>software<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">key</span>&gt;</span>title<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">string</span>&gt;</span>Hiclub<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">        <span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">plist</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>pist文件中需要注意：</p>
<ul>
<li>software-package对应的链接即github上ipa文件所在地址</li>
<li>display-image为安装过程中iphone桌面上显示的图标</li>
<li>bundle-identifier为打包ipa中所配置的id</li>
<li>bundle-version为当前app版本</li>
</ul>
<p><strong>3，配置install.html文件，用来生成安装页</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"Content-Type"</span> <span class="attribute">content</span>=<span class="value">"text/html; charset=UTF-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">title</span>&gt;</span>Install<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">p</span> <span class="attribute">align</span>=<span class="value">center</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">font</span> <span class="attribute">size</span>=<span class="value">"10"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">a</span> <span class="attribute">style</span>=<span class="value">"color:#69DEDA"</span> <span class="attribute">href</span>=<span class="value">"itms-services://?action=download-manifest&amp;url=***/install.plist"</span>&gt;</span>点击安装<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="title">font</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>install.plist即为该文件在github上的链接地址，然后将全部文件push到github。</p>
<p><strong>4，生成在线安装链接</strong> </p>
<p><img src="http://7xkptx.com1.z0.glb.clouddn.com/gitdcehe7654grvew.png" alt="htmlpreview"><br>由于github上的安装页面install.html无法直接预览，通过一个非常使用的小工具<a href="http://htmlpreview.github.io/" target="_blank" rel="external">htmlpreview</a>，将install.html原链接转换为可预览的链接，如上图所示。最后用iPhone Safari 打开新生成的链接就可以安装了。 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/09/05/使用github发布ios应用/" data-id="cijdtvvul000enyb1mtr7huno" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OTA/">OTA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/github/">github</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/App-Store/">App Store</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mac/">mac</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/svn/">svn</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IAP/">IAP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OTA/">OTA</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/background/">background</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/">mac</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/svn/">svn</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/推送/">推送</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/IAP/" style="font-size: 10px;">IAP</a> <a href="/tags/OTA/" style="font-size: 10px;">OTA</a> <a href="/tags/background/" style="font-size: 10px;">background</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/mac/" style="font-size: 10px;">mac</a> <a href="/tags/svn/" style="font-size: 10px;">svn</a> <a href="/tags/推送/" style="font-size: 10px;">推送</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/01/13/聊一聊iOS后台任务/">聊一聊iOS后台任务</a>
          </li>
        
          <li>
            <a href="/2015/12/24/ iOS面试总结/">iOS面试总结</a>
          </li>
        
          <li>
            <a href="/2015/12/14/几款mac小工具推荐/">几款mac小工具推荐</a>
          </li>
        
          <li>
            <a href="/2015/11/10/常用的SVN命令小结/">常用的SVN命令小结</a>
          </li>
        
          <li>
            <a href="/2015/11/09/APNS测试与部署/">APNS测试与部署</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Pandora<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>